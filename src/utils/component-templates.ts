/**
 * Component Template Generator
 * Generates template content for different component types
 */

import { ComponentType, ComponentTemplate, RegistryUpdate } from '../types/index.js';
import { generateClassName, generateVariableName, generateRegistryKey } from './project-detector.js';

/**
 * Generate component template based on type and configuration
 */
export function generateComponentTemplate(
  componentType: ComponentType,
  componentName: string,
  options: {
    description?: string;
    author?: string;
    projectName?: string;
  } = {}
): ComponentTemplate {
  const className = generateClassName(componentName, componentType);
  const variableName = generateVariableName(componentName, componentType);
  const registryKey = generateRegistryKey(componentName);
  const description = options.description || `Custom ${componentType} for ${componentName}`;
  const author = options.author || 'Generated by mcp-server-generator';

  switch (componentType) {
    case 'tool':
      return generateToolTemplate(className, variableName, registryKey, description, author);
    case 'resource':
      return generateResourceTemplate(className, variableName, registryKey, description, author);
    case 'prompt':
      return generatePromptTemplate(className, variableName, registryKey, description, author);
    case 'service':
      return generateServiceTemplate(className, variableName, registryKey, description, author);
    case 'transport':
      return generateTransportTemplate(className, variableName, registryKey, description, author);
    case 'util':
      return generateUtilTemplate(className, variableName, registryKey, description, author);
    default:
      throw new Error(`Unknown component type: ${componentType}`);
  }
}

function generateToolTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { logger } from "../utils/logger.js";
import { BaseTool, ToolStats } from "./index.js";

// Input schema for the ${registryKey} tool
const ${className}Schema = z.object({
  input: z.string().describe("Input parameter for the ${registryKey} tool"),
  // Add more parameters as needed
  options: z.object({
    format: z.enum(["json", "text"]).default("json").optional(),
    verbose: z.boolean().default(false).optional(),
  }).optional(),
});

type ${className}Input = z.infer<typeof ${className}Schema>;

export class ${className} implements BaseTool {
  name = "${registryKey}";

  register(server: McpServer, stats: ToolStats): void {
    server.registerTool(
      this.name,
      {
        title: "${className}",
        description: "${description}",
        inputSchema: {
          input: z.string().describe("Input parameter for the ${registryKey} tool"),
          // Add more parameters as needed
          options: z.object({
            format: z.enum(["json", "text"]).default("json").optional(),
            verbose: z.boolean().default(false).optional(),
          }).optional(),
        }
      },
      async (args) => {
        try {
          logger.debug(\`Executing \${this.name} tool\`);
          stats.toolCalls++;

          // Validate input
          const validatedInput = ${className}Schema.parse(args);
          
          // Execute tool logic
          const result = await this.execute(validatedInput);

          return {
            content: [
              {
                type: "text",
                text: typeof result === "string" ? result : JSON.stringify(result, null, 2),
              },
            ],
          };
        } catch (error) {
          logger.error(\`Error in \${this.name} tool:\`, error);
          return {
            content: [
              {
                type: "text",
                text: \`Error: \${error instanceof Error ? error.message : "Unknown error"}\`,
              },
            ],
            isError: true,
          };
        }
      }
    );

    logger.info(\`Registered tool: \${this.name}\`);
  }

  /**
   * Execute the ${registryKey} tool logic
   */
  private async execute(input: ${className}Input): Promise<any> {
    logger.debug(\`Executing \${this.name} with input:\`, input);

    // TODO: Implement your tool logic here
    return {
      message: \`${className} executed successfully\`,
      input: input.input,
      timestamp: new Date().toISOString(),
      // Add your custom response data here
    };
  }
}`;

  const indexUpdateContent = `export { ${className} } from "./${registryKey}-tool.js";`;

  const registryUpdates: RegistryUpdate[] = [
    {
      registryType: 'tool',
      addImport: `import { ${className} } from "./${registryKey}-tool.js";`,
      addRegistration: `this.tools.set('${registryKey}', new ${className}());`,
      addInitialization: `// ${className} - ${description}`
    }
  ];

  return {
    componentType: 'tool',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates
  };
}

function generateResourceTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { logger } from "../utils/logger.js";
import { ConfigManager } from "../core/config.js";
import { HealthChecker } from "../utils/health.js";
import { BaseResource, ResourceStats } from "./index.js";

export class ${className} implements BaseResource {
  name = "${registryKey}";

  register(
    server: McpServer,
    stats: ResourceStats,
    healthChecker?: HealthChecker,
    configManager?: ConfigManager
  ): void {
    // Register info resource
    server.registerResource(
      \`\${this.name}-info\`,
      \`${registryKey}://info\`,
      {
        title: "${registryKey} Information",
        description: "${description}",
        mimeType: "text/plain"
      },
      async () => {
        logger.debug(\`Reading \${this.name} info resource\`);
        stats.resourceAccess++;
        return {
          contents: [{
            uri: \`${registryKey}://info\`,
            text: this.getInfoContent(),
            mimeType: "text/plain"
          }]
        };
      }
    );

    // Register data resource
    server.registerResource(
      \`\${this.name}-data\`,
      \`${registryKey}://data\`,
      {
        title: "${registryKey} Data",
        description: "Data and configuration for ${registryKey}",
        mimeType: "application/json"
      },
      async () => {
        logger.debug(\`Reading \${this.name} data resource\`);
        stats.resourceAccess++;
        return {
          contents: [{
            uri: \`${registryKey}://data\`,
            text: JSON.stringify(this.getDataContent(), null, 2),
            mimeType: "application/json"
          }]
        };
      }
    );

    logger.info(\`Registered resource: \${this.name}\`);
  }

  /**
   * Get information content for the ${registryKey} resource
   */
  private getInfoContent(): string {
    return \`# ${className} Information

${description}

## Features
- Custom resource functionality
- Data access and management
- Configuration support

## Usage
Access this resource using the URI: ${registryKey}://info

## Generated
Created by: ${author}
Timestamp: \${new Date().toISOString()}
\`;
  }

  /**
   * Get data content for the ${registryKey} resource
   */
  private getDataContent(): any {
    return {
      name: "${registryKey}",
      description: "${description}",
      type: "resource",
      capabilities: [
        "information-access",
        "data-retrieval",
        "configuration-support"
      ],
      metadata: {
        created: new Date().toISOString(),
        author: "${author}",
        version: "1.0.0"
      },
      // TODO: Add your custom data here
      customData: {
        example: "Add your resource data here"
      }
    };
  }
}`;

  const indexUpdateContent = `export { ${className} } from "./${registryKey}-resource.js";`;

  const registryUpdates: RegistryUpdate[] = [
    {
      registryType: 'resource',
      addImport: `import { ${className} } from "./${registryKey}-resource.js";`,
      addRegistration: `this.resources.set('${registryKey}', new ${className}());`,
      addInitialization: `// ${className} - ${description}`
    }
  ];

  return {
    componentType: 'resource',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates
  };
}

function generatePromptTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { logger } from "../utils/logger.js";
import { BasePrompt, PromptStats } from "./index.js";

// Arguments schema for the ${registryKey} prompt
const ${className}ArgumentsSchema = z.object({
  topic: z.string().describe("The main topic or subject for the prompt"),
  context: z.string().optional().describe("Additional context or background information"),
  format: z.enum(["detailed", "summary", "bullet-points"]).default("detailed").describe("Output format preference"),
  tone: z.enum(["professional", "casual", "academic", "creative"]).default("professional").describe("Tone of the response"),
});

type ${className}Arguments = z.infer<typeof ${className}ArgumentsSchema>;

export class ${className} implements BasePrompt {
  name = "${registryKey}";

  register(server: McpServer, stats: PromptStats): void {
    server.registerPrompt(
      this.name,
      {
        title: "${className}",
        description: "${description}",
        argsSchema: {
          topic: z.string().describe("The main topic or subject for the prompt"),
          context: z.string().optional().describe("Additional context or background information"),
          format: z.enum(["detailed", "summary", "bullet-points"]).optional().describe("Output format preference"),
          tone: z.enum(["professional", "casual", "academic", "creative"]).optional().describe("Tone of the response"),
        }
      },
      async (args) => {
        try {
          logger.debug(\`Executing prompt: \${this.name}\`);
          stats.promptExecutions++;

          // Validate arguments
          const validatedArgs = ${className}ArgumentsSchema.parse(args);
          
          // Generate prompt content
          const promptContent = this.generatePrompt(validatedArgs);

          return {
            messages: [
              {
                role: "user",
                content: {
                  type: "text",
                  text: promptContent,
                },
              },
            ],
          };
        } catch (error) {
          logger.error(\`Error in prompt \${this.name}:\`, error);
          throw error;
        }
      }
    );

    logger.info(\`Registered prompt: \${this.name}\`);
  }

  /**
   * Generate the prompt content based on arguments
   */
  private generatePrompt(args: ${className}Arguments): string {
    const { topic, context, format, tone } = args;

    let prompt = \`You are an expert assistant helping with: \${topic}\`;

    if (context) {
      prompt += \`\\n\\nContext: \${context}\`;
    }

    prompt += \`\\n\\nPlease provide a response that is:\`;
    prompt += \`\\n- Tone: \${tone}\`;
    prompt += \`\\n- Format: \${format}\`;

    switch (format) {
      case "summary":
        prompt += \`\\n- Concise and to the point\`;
        prompt += \`\\n- Highlight key information only\`;
        break;
      case "bullet-points":
        prompt += \`\\n- Organized as clear bullet points\`;
        prompt += \`\\n- Easy to scan and understand\`;
        break;
      case "detailed":
      default:
        prompt += \`\\n- Comprehensive and thorough\`;
        prompt += \`\\n- Include relevant details and explanations\`;
        break;
    }

    // TODO: Customize your prompt generation logic here
    prompt += \`\\n\\nTopic to address: \${topic}\`;

    return prompt;
  }
}`;

  const indexUpdateContent = `export { ${className} } from "./${registryKey}-prompt.js";`;

  const registryUpdates: RegistryUpdate[] = [
    {
      registryType: 'prompt',
      addImport: `import { ${className} } from "./${registryKey}-prompt.js";`,
      addRegistration: `this.prompts.set('${registryKey}', new ${className}());`,
      addInitialization: `// ${className} - ${description}`
    }
  ];

  return {
    componentType: 'prompt',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates
  };
}

function generateServiceTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { logger } from "../utils/logger.js";

export interface ${className}Options {
  // TODO: Define your service options here
  enableLogging?: boolean;
  maxRetries?: number;
  timeout?: number;
}

export interface ${className}Result {
  success: boolean;
  data?: any;
  error?: string;
  timestamp: string;
}

export class ${className} {
  private options: ${className}Options;

  constructor(options: ${className}Options = {}) {
    this.options = {
      enableLogging: true,
      maxRetries: 3,
      timeout: 5000,
      ...options,
    };

    if (this.options.enableLogging) {
      logger.info(\`Initialized \${${className}.name} service\`);
    }
  }

  /**
   * Execute the main service operation
   */
  async execute(input: any): Promise<${className}Result> {
    const startTime = Date.now();
    
    try {
      if (this.options.enableLogging) {
        logger.debug(\`Executing \${${className}.name} service with input:\`, input);
      }

      // TODO: Implement your service logic here
      const result = await this.processInput(input);

      const response: ${className}Result = {
        success: true,
        data: result,
        timestamp: new Date().toISOString(),
      };

      if (this.options.enableLogging) {
        const duration = Date.now() - startTime;
        logger.info(\`\${${className}.name} service completed in \${duration}ms\`);
      }

      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      
      if (this.options.enableLogging) {
        logger.error(\`\${${className}.name} service error:\`, error);
      }

      return {
        success: false,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      };
    }
  }

  /**
   * Process the input data
   */
  private async processInput(input: any): Promise<any> {
    // TODO: Implement your custom processing logic here
    
    // Example processing with timeout
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(\`Service timeout after \${this.options.timeout}ms\`));
      }, this.options.timeout);

      // Simulate async processing
      setTimeout(() => {
        clearTimeout(timer);
        resolve({
          processedInput: input,
          result: \`Processed by \${${className}.name}\`,
          metadata: {
            processingTime: Date.now(),
            serviceVersion: "1.0.0",
          },
        });
      }, 100);
    });
  }

  /**
   * Validate input data
   */
  validateInput(input: any): boolean {
    // TODO: Implement your input validation logic
    return input !== null && input !== undefined;
  }

  /**
   * Get service status and statistics
   */
  getStatus(): any {
    return {
      name: "${registryKey}",
      description: "${description}",
      status: "active",
      configuration: this.options,
      capabilities: [
        "data-processing",
        "async-operations",
        "error-handling",
        "timeout-management"
      ],
      metadata: {
        created: new Date().toISOString(),
        author: "${author}",
        version: "1.0.0"
      }
    };
  }
}`;

  const indexUpdateContent = `export { ${className} } from "./${registryKey}.js";`;

  return {
    componentType: 'service',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates: []
  };
}

function generateTransportTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import { logger } from "../utils/logger.js";

export interface ${className}Options {
  // TODO: Define your transport options here
  host?: string;
  port?: number;
  timeout?: number;
  enableCompression?: boolean;
}

export class ${className} implements Transport {
  private options: ${className}Options;
  private isConnected: boolean = false;

  constructor(options: ${className}Options = {}) {
    this.options = {
      host: "localhost",
      port: 8080,
      timeout: 30000,
      enableCompression: true,
      ...options,
    };

    logger.info(\`Initialized \${${className}.name} transport\`);
  }

  /**
   * Start the transport
   */
  async start(): Promise<void> {
    try {
      logger.info(\`Starting \${${className}.name} transport...\`);
      
      // TODO: Implement your transport start logic here
      await this.initializeConnection();
      
      this.isConnected = true;
      logger.info(\`\${${className}.name} transport started successfully\`);
    } catch (error) {
      logger.error(\`Failed to start \${${className}.name} transport:\`, error);
      throw error;
    }
  }

  /**
   * Close the transport
   */
  async close(): Promise<void> {
    try {
      logger.info(\`Closing \${${className}.name} transport...\`);
      
      // TODO: Implement your transport close logic here
      await this.closeConnection();
      
      this.isConnected = false;
      logger.info(\`\${${className}.name} transport closed successfully\`);
    } catch (error) {
      logger.error(\`Failed to close \${${className}.name} transport:\`, error);
      throw error;
    }
  }

  /**
   * Send data through the transport
   */
  async send(data: any): Promise<void> {
    if (!this.isConnected) {
      throw new Error("Transport is not connected");
    }

    try {
      logger.debug(\`Sending data via \${${className}.name} transport\`);
      
      // TODO: Implement your send logic here
      await this.transmitData(data);
      
    } catch (error) {
      logger.error(\`Failed to send data via \${${className}.name} transport:\`, error);
      throw error;
    }
  }

  /**
   * Initialize the connection
   */
  private async initializeConnection(): Promise<void> {
    // TODO: Implement your connection initialization logic
    logger.debug(\`Initializing connection to \${this.options.host}:\${this.options.port}\`);
    
    // Simulate connection setup
    return new Promise((resolve) => {
      setTimeout(resolve, 100);
    });
  }

  /**
   * Close the connection
   */
  private async closeConnection(): Promise<void> {
    // TODO: Implement your connection close logic
    logger.debug("Closing connection");
    
    // Simulate connection cleanup
    return new Promise((resolve) => {
      setTimeout(resolve, 50);
    });
  }

  /**
   * Transmit data
   */
  private async transmitData(data: any): Promise<void> {
    // TODO: Implement your data transmission logic
    logger.debug("Transmitting data:", data);
    
    // Simulate data transmission
    return new Promise((resolve) => {
      setTimeout(resolve, 10);
    });
  }

  /**
   * Get transport status
   */
  getStatus(): any {
    return {
      name: "${registryKey}",
      description: "${description}",
      connected: this.isConnected,
      configuration: this.options,
      capabilities: [
        "bidirectional-communication",
        "error-handling",
        "connection-management",
        "data-compression"
      ],
      metadata: {
        created: new Date().toISOString(),
        author: "${author}",
        version: "1.0.0"
      }
    };
  }
}`;

  const indexUpdateContent = `export { ${className} } from "./${registryKey}-transport.js";`;

  return {
    componentType: 'transport',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates: []
  };
}

function generateUtilTemplate(
  className: string,
  variableName: string,
  registryKey: string,
  description: string,
  author: string
): ComponentTemplate {
  const templateContent = `/**
 * ${className}
 * ${description}
 * Generated by: ${author}
 */

import { logger } from "./logger.js";

export interface ${className}Options {
  // TODO: Define your utility options here
  enableDebug?: boolean;
  cacheSize?: number;
  timeout?: number;
}

export class ${className} {
  private options: ${className}Options;
  private cache: Map<string, any> = new Map();

  constructor(options: ${className}Options = {}) {
    this.options = {
      enableDebug: false,
      cacheSize: 100,
      timeout: 5000,
      ...options,
    };

    if (this.options.enableDebug) {
      logger.debug(\`Initialized \${${className}.name} utility\`);
    }
  }

  /**
   * Main utility function
   */
  process(input: any): any {
    try {
      if (this.options.enableDebug) {
        logger.debug(\`Processing input with \${${className}.name}\`);
      }

      // Check cache first
      const cacheKey = this.generateCacheKey(input);
      if (this.cache.has(cacheKey)) {
        if (this.options.enableDebug) {
          logger.debug("Returning cached result");
        }
        return this.cache.get(cacheKey);
      }

      // TODO: Implement your processing logic here
      const result = this.performProcessing(input);

      // Cache the result
      this.setCacheValue(cacheKey, result);

      return result;
    } catch (error) {
      if (this.options.enableDebug) {
        logger.error(\`Error in \${${className}.name}:\`, error);
      }
      throw error;
    }
  }

  /**
   * Perform the actual processing
   */
  private performProcessing(input: any): any {
    // TODO: Implement your custom processing logic
    return {
      processed: true,
      input: input,
      output: \`Processed by \${${className}.name}\`,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Generate cache key for input
   */
  private generateCacheKey(input: any): string {
    // Simple string conversion for caching
    return typeof input === "string" ? input : JSON.stringify(input);
  }

  /**
   * Set cache value with size limit
   */
  private setCacheValue(key: string, value: any): void {
    // Implement LRU-style cache with size limit
    if (this.cache.size >= this.options.cacheSize!) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }

  /**
   * Clear the cache
   */
  clearCache(): void {
    this.cache.clear();
    if (this.options.enableDebug) {
      logger.debug(\`Cleared cache for \${${className}.name}\`);
    }
  }

  /**
   * Get utility statistics
   */
  getStats(): any {
    return {
      name: "${registryKey}",
      description: "${description}",
      cacheSize: this.cache.size,
      maxCacheSize: this.options.cacheSize,
      configuration: this.options,
      capabilities: [
        "data-processing",
        "caching",
        "performance-optimization",
        "configurable-behavior"
      ],
      metadata: {
        created: new Date().toISOString(),
        author: "${author}",
        version: "1.0.0"
      }
    };
  }
}

// Export utility functions for common use cases
export function ${variableName}Helper(input: any, options?: ${className}Options): any {
  const utility = new ${className}(options);
  return utility.process(input);
}

export function create${className}(options?: ${className}Options): ${className} {
  return new ${className}(options);
}`;

  const indexUpdateContent = `export { ${className}, ${variableName}Helper, create${className} } from "./${registryKey}.js";`;

  return {
    componentType: 'util',
    templateContent,
    indexUpdateContent,
    requiredImports: [],
    registryUpdates: []
  };
}
